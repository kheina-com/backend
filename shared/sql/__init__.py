from dataclasses import dataclass
from dataclasses import field as dataclass_field
from enum import Enum
from functools import lru_cache, partial
from re import compile
from types import TracebackType
from typing import Any, Awaitable, Callable, Dict, List, Optional, Protocol, Self, Tuple, Type, Union

from psycopg import AsyncClientCursor, AsyncConnection, AsyncCursor, Binary, OperationalError
from psycopg_pool import AsyncConnectionPool
from pydantic import BaseModel
from pydantic.fields import ModelField

from ..config.credentials import fetch
from ..logging import Logger, getLogger
from ..models._shared import PostId
from ..timing import timed
from .query import Field, Insert, Operator, Query, Table, Update, Value, Where


_orm_regex = compile(r'orm:"([^\n]*?)(?<!\\)"')
_orm_attr_regex = compile(r'(col|map|pk|gen|default)(?:\[([\s\S]*?)\])?')


@dataclass
class FieldAttributes :
	map: List[Tuple[Tuple[str, ...], str]] = dataclass_field(default_factory=list)
	"""
	list of paths to columns.
	first entry of each list member is the route to the field within the model.
	second entry is the column that field belongs to within the database.
	"""

	column: Optional[str]  = None
	"""
	database column this field belongs to
	"""

	primary_key: Optional[bool] = None
	"""
	field is a primary key
	"""

	generated: Optional[bool] = None
	"""
	field may be generated by the database
	"""

	default: Optional[bool] = None
	"""
	field has a database-defined default value
	"""

	ignore: Optional[bool] = None
	"""
	field does not exist in the database
	"""


class AwaitableQuery(Protocol) :
    def __call__(
		self:      Self,
		sql:       Query,
		params:    tuple[Any, ...] = (),
		fetch_one: bool            = False,
		fetch_all: bool            = False,
	) -> Awaitable[Any] : ...


class SqlInterface :

	db:   Dict[str, str] = fetch('db', Dict[str, str])
	pool: AsyncConnectionPool

	_read_conversions = { }

	def __init__(self: Self, long_query_metric: float = 1, conversions: Dict[type, Callable] = { }) -> None :
		self.logger: Logger = getLogger()
		self._long_query = long_query_metric	
		self._conversions: Dict[type, Callable] = {
			tuple: list,
			bytes: Binary,
			Enum: lambda x : x.name,
			PostId: PostId.int,
			**conversions,
		}


	async def open(self: Self) :
		if getattr(SqlInterface, 'pool', None) is None :
			SqlInterface.pool = AsyncConnectionPool(' '.join(map('='.join, SqlInterface.db.items())), open=False)
			await SqlInterface.pool.open()


	def _convert_item(self: Self, item: Any) -> Any :
		for cls in type(item).__mro__ :
			if cls in self._conversions :
				return self._conversions[cls](item)

		return item


	@timed
	async def query_async(
		self:      Self,
		sql:       Union[str, Query],
		params:    tuple[Any, ...] = (),
		commit:    bool            = False,
		fetch_one: bool            = False,
		fetch_all: bool            = False,
		attempts:  int             = 3,
	) -> Any :
		await self.open()

		if isinstance(sql, Query) :
			sql, params = sql.build()

		params = tuple(map(self._convert_item, params))

		for _ in range(attempts) :
			async with SqlInterface.pool.connection() as conn :
				try :
					async with AsyncClientCursor(conn) as cur :
						# TODO: convert fuzzly's Query implementation into a psycopg composable
						await cur.execute(sql, params) # type: ignore

						if commit :
							await conn.commit()

						else :
							await conn.rollback()

						if fetch_one :
							return await cur.fetchone()

						elif fetch_all :
							return await cur.fetchall()

						return

				except OperationalError :
					pass

				except Exception as e :
					self.logger.warning({
						'message': 'unexpected error encountered during sql query.',
						'query': sql,
					}, exc_info=e)
					# now attempt to recover by rolling back
					raise


	def transaction(self: Self) -> 'Transaction' :
		return Transaction(self)


	async def close(self: Self) -> int :
		if not SqlInterface.pool.closed :
			await SqlInterface.pool.close()
		return SqlInterface.pool.closed


	@staticmethod
	def _table_name(model: Union[BaseModel, Type[BaseModel]]) -> Table :
		if not hasattr(model, '__table_name__') :
			raise AttributeError('model must be defined with the __table_name__ attribute')

		table_name = getattr(model, '__table_name__')
		if not isinstance(table_name, Table) :
			table_name = Table(table_name)

		return table_name


	@lru_cache(maxsize=None)
	@staticmethod
	def _orm_attr_parser(field: ModelField) -> FieldAttributes :
		if not field.field_info.description :
			return FieldAttributes()

		match = _orm_regex.search(field.field_info.description)
		if not match :
			return FieldAttributes()

		orm_info = match.group(1).replace(r'\"', r'"')

		if orm_info == '-' :
			return FieldAttributes(ignore=True)

		attributes = FieldAttributes()
		for i in orm_info.split(';') :
			match = _orm_attr_regex.search(i)
			if not match :
				continue

			attr_key = match.group(1)
			if attr_key == 'col' :
				attributes.column = match.group(2).strip()

			elif attr_key == 'map' :
				for m in match.group(2).split(',') :
					path, col = m.split(':')
					attributes.map.append((tuple(path.split('.')), str(col)))

			elif attr_key == 'pk' :
				attributes.primary_key = True

			elif attr_key == 'gen' :
				attributes.generated = True

			elif attr_key == 'default' :
				attributes.default = True

		return attributes


	async def insert[T: BaseModel](self: Self, model: T, query: Optional[AwaitableQuery] = None) -> T :
		"""
		inserts a model into the database table defined by __table_name__.

		Available field attributes:
			gen - indicates that the column is generated and should be assigned on return
			default - indicates that the column has a default value when null, and will be assigned when not provided
			col[column] - changes the column used for the field
			map[subtype.field:column,field:column2] - maps a subtype's field to columns. separate nested fields by periods.
		"""
		table: Table                 = self._table_name(model)
		d:     Dict[str, Any]        = model.dict()
		paths: List[Tuple[str, ...]] = []
		vals:  List[Value]           = []
		cols:  List[str]             = []
		ret:   List[str]             = []

		for key, field in model.__fields__.items() :
			attrs = SqlInterface._orm_attr_parser(field)
			if attrs.ignore :
				continue

			if attrs.generated :
				ret.append(attrs.column or field.name)
				paths.append((key,))
				continue

			if attrs.map :
				for m in attrs.map :
					param = d[key]

					if param :
						for k in m[0] :
							if isinstance(param, dict) :
								param = param.get(k)

							else :
								param = getattr(param, k, None)

					if attrs.default is not None and param == field.default :
						ret.append(m[1])
						paths.append(tuple([key, *m[0]]))

					else :
						cols.append(m[1])
						vals.append(Value(param))

			else :
				if attrs.default is not None and d[key] == field.default :
					ret.append(attrs.column or field.name)
					paths.append((key,))

				else :
					cols.append(attrs.column or field.name)
					vals.append(Value(d[key]))

		sql: Query = Query(table).insert(Insert(*cols).values(*vals))

		if ret :
			sql.returning(*ret)

		if not query :
			query = partial(self.query_async, commit=True)

		assert query
		data: Tuple[Any, ...] = await query(sql, fetch_one=bool(ret))

		for i, path in enumerate(paths) :
			v2 = d

			for k in path :
				v = v2
				if k in v :
					v2 = v[k]

				else :
					v2 = v[k] = { }

			v[k] = data[i]

		return model.parse_obj(d)


	@staticmethod
	def _read_convert(value: Any) -> Any :
		if type(value) in SqlInterface._read_conversions :
			return SqlInterface._read_conversions[type(value)](value)

		return value


	@staticmethod
	def _assign_field_values[T: BaseModel](model: Type[T], data: Tuple[Any, ...]) -> T :
		i = 0
		d: dict = { }
		for key, field in model.__fields__.items() :
			attrs = SqlInterface._orm_attr_parser(field)
			if attrs.ignore :
				continue

			if attrs.map :
				unset: bool = True

				for m in attrs.map :
					v2 = d.get(key, { })

					for k in m[0] :
						v = v2
						if k in v :
							v2 = v[k]

						else :
							v2 = v[k] = { }

					if data[i] :
						unset = False

					v[k] = SqlInterface._read_convert(data[i])
					d[key] = v
					i += 1

				if unset :
					d[key] = field.default

			else :
				d[key] = SqlInterface._read_convert(data[i])
				i += 1

		return model.parse_obj(d)


	async def select[T: BaseModel](self: Self, model: T, query: Optional[AwaitableQuery] = None) -> T :
		"""
		fetches a model from the database table defined by __table_name__ using the populated field indicated by the pk

		Available field attributes:
			pk - specifies the field as the primary key. field value must be populated.
			col[column] - changes the column used for the field
			map[subtype.field:column,field:column2] - maps a subtype's field to columns. separate nested fields by periods.
		"""
		table = self._table_name(model)
		d     = model.dict()
		sql   = Query(table)
		_, t  = str(table).rsplit('.', 1)
		pk    = 0

		for key, field in model.__fields__.items() :
			attrs = SqlInterface._orm_attr_parser(field)
			if attrs.ignore :
				continue

			if attrs.map :
				for m in attrs.map :
					sql.select(Field(t, m[1]))

			else :
				sql.select(Field(t, attrs.column or field.name))

			if attrs.primary_key :
				pk += 1
				sql.where(Where(
					Field(t, attrs.column or field.name),
					Operator.equal,
					Value(d[key]),
				))

		assert pk > 0

		if not query :
			query = partial(self.query_async, commit=False)

		assert query
		data: Tuple[Any, ...] = await query(sql, fetch_one=True)

		if not data :
			raise KeyError('value does not exist in database')

		return SqlInterface._assign_field_values(type(model), data)


	async def update[T: BaseModel](self: Self, model: T, query: Optional[AwaitableQuery] = None) -> T :
		"""
		updates a model in the database table defined by __table_name__.

		Available field attributes:
			gen - indicates that the column is generated and should be assigned on return
			default - indicates that the column has a default value when null, and will be assigned when not provided
			col[column] - changes the column used for the field
			map[subtype.field:column,field:column2] - maps a subtype's field to columns. separate nested fields by periods.
		"""
		table: Table                 = self._table_name(model)
		sql:   Query                 = Query(table)
		d:     Dict[str, Any]        = model.dict()
		paths: List[Tuple[str, ...]] = []
		vals:  List[Value]           = []
		cols:  List[str]             = []
		ret:   List[str]             = []

		_, t  = str(table).rsplit('.', 1)
		pk    = 0

		for key, field in model.__fields__.items() :
			attrs = SqlInterface._orm_attr_parser(field)
			if attrs.ignore :
				continue
			
			if attrs.primary_key :
				pk += 1
				sql.where(Where(
					Field(t, attrs.column or field.name),
					Operator.equal,
					Value(d[key]),
				))
				continue

			if attrs.generated :
				ret.append(attrs.column or field.name)
				paths.append((key,))
				continue

			if attrs.map :
				for m in attrs.map :
					param = d[key]

					if param :
						for k in m[0] :
							if isinstance(param, dict) :
								param = param.get(k)

							else :
								param = getattr(param, k, None)

					cols.append(m[1])
					vals.append(Value(param))

			else :
				cols.append(attrs.column or field.name)
				vals.append(Value(d[key]))

		for i in range(len(cols)) :
			sql.update(Update(
				cols[i],
				vals[i],
			))

		if ret :
			sql.returning(*ret)

		assert pk > 0

		if not query :
			query = partial(self.query_async, commit=True)

		assert query
		data: Tuple[Any, ...] = await query(sql, fetch_one=bool(ret))

		for i, path in enumerate(paths) :
			v2 = d

			for k in path :
				v = v2
				if k in v :
					v2 = v[k]

				else :
					v2 = v[k] = { }

			v[k] = data[i]

		return model.parse_obj(d)


	async def delete(self: Self, model: BaseModel, query: Optional[AwaitableQuery] = None) -> None :
		"""
		deletes a model from the database table defined by __table_name__ using the populated field indicated by the pk

		Available field attributes:
			pk - specifies the field as the primary key. field value must be populated.
			col[column] - changes the column used for the field
			map[subtype.field:column,field:column2] - maps a subtype's field to columns. separate nested fields by periods.
		"""
		table = self._table_name(model)
		d     = model.dict()
		sql   = Query(table).delete()
		_, t  = str(table).rsplit('.', 1)
		pk    = 0

		for key, field in model.__fields__.items() :
			attrs = SqlInterface._orm_attr_parser(field)
			if attrs.primary_key :
				pk += 1
				sql.where(Where(
					Field(t, attrs.column or field.name),
					Operator.equal,
					Value(d[key]),
				))

		assert pk > 0

		if not query :
			query = partial(self.query_async, commit=True)

		assert query
		await query(sql)


	async def where[T: BaseModel](self: Self, model: Type[T], *where: Where, query: Optional[AwaitableQuery] = None) -> List[T] :
		table = self._table_name(model)
		sql   = Query(table).where(*where)
		_, t  = str(table).rsplit('.', 1)

		for _, field in model.__fields__.items() :
			attrs = SqlInterface._orm_attr_parser(field)
			if attrs.ignore :
				continue

			if attrs.map :
				for m in attrs.map :
					sql.select(Field(t, m[1]))

			else :
				sql.select(Field(t, attrs.column or field.name))

		if not query :
			query = partial(self.query_async, commit=False)

		assert query
		data: List[Tuple[Any, ...]] = await query(sql, fetch_all=True)

		return [SqlInterface._assign_field_values(model, row) for row in data]


class Transaction :

	def __init__(self: 'Transaction', sql: SqlInterface) :
		self._sql:   SqlInterface               = sql
		self._conn:  Optional[AsyncConnection]  = None
		self.conn:   Optional[AsyncConnection]  = None
		self.nested: int                        = 0

		self.insert = partial(self._sql.insert, query=self.query_async)
		self.select = partial(self._sql.select, query=self.query_async)
		self.update = partial(self._sql.update, query=self.query_async)
		self.delete = partial(self._sql.delete, query=self.query_async)
		self.where  = partial(self._sql.where,  query=self.query_async)


	async def __aenter__(self: Self) :
		if self._conn :
			self.nested += 1

		else :
			self._conn = await self._sql.pool.getconn()
			self.conn  = await self._conn.__aenter__()

		return self


	async def __aexit__(self: Self, exc_type: Optional[Type[BaseException]], exc_obj: Optional[BaseException], exc_tb: Optional[TracebackType]) :
		if not self.nested :
			if self.conn :
				await self.conn.__aexit__(exc_type, exc_obj, exc_tb)
				self.conn = None

			if self._conn :
				await self._sql.pool.putconn(self._conn)
				self._conn = None

		else :
			self.nested -= 1


	async def commit(self: Self) :
		if self.conn :
			await self.conn.commit()


	async def rollback(self: Self) :
		if self.conn :
			await self.conn.rollback()


	@timed
	async def query_async(
		self:      Self,
		sql:       Union[str, Query],
		params:    tuple[Any, ...] = (),
		fetch_one: bool            = False,
		fetch_all: bool            = False,
	) -> Any :
		if isinstance(sql, Query) :
			sql, params = sql.build()

		assert self.conn
		params = tuple(map(self._sql._convert_item, params))

		try :
			# TODO: convert fuzzly's Query implementation into a psycopg composable
			cur: AsyncCursor = await self.conn.execute(sql, params) # type: ignore

			if fetch_one :
				return await cur.fetchone()

			elif fetch_all :
				return await cur.fetchall()

		except Exception as e :
			self._sql.logger.warning({
				'message': 'unexpected error encountered during sql query.',
				'query': sql,
			}, exc_info=e)
			raise
